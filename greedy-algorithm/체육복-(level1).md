# 1. 그리디 알고리즘 이란?

알고리즘 중 가장 기본이 되고 쉬운 알고리즘으로 알려져있습니다. 보통 그리디 알고리즘 혹은 탐욕 알고리즘으로 불리는데, 간단히 정의를 하자면 현재 상황에서 선택할 수 있는 방법 중 가장 좋은 방법을 선택하는 방법을 그리디 알고리즘 혹은 탐욕 알고리즘이라 부릅니다. 

예시를 보며 설명해 보겠습니다. 
 
 ![](https://work-it.co.kr:8080/static/img/49fa16e6bbd8cd548d98299526ba423a.png)
 
 위 그림의 목표는 지나는 노드의 총 합이 최대 값이 나오도록 하는 것이 목표입니다. 
 
 현재 위 그림은 노드의 수가 적고 간단하기 때문에 한눈에 보고 어떤 루트로 지나야 최대값이 나오는지 알 수 있습니다. 
 
 현재 우리가 보고 생각하기에는 **[시작 => 7 => 100]** 의 루트가 총합 107로 최대 값이 나오는 루트임을 알 수 있습니다. 하지만 그리디 알고리즘을 사용해서 푼다면 다른 루트가 나옵니다. 그리디 알고리즘은 앞서 설명 했듯이, **현재 상황**에서 가장 최적의 방법을 선택하는 알고리즘이기 때문에 시작 후에 선택할 수 있는 노드중 가장 큰 노드를 고른후 그 다음도 같은 방법으로 최대 값을 가지는 루트를 찾습니다.
 
 위 그림으로 설명하자면 **[시작 => 13 (1 < 13) => 11 (5 < 11)]** 순의 루트를 고르게 됩니다. 이 처럼 그리디 알고리즘이란 해당 방법이 전체적인 과정으로 볼때에 가장 최적의 방법은 아니지만 현재 바로 앞에 놓인 문제를 해결 하는 방법 중에서는 가장 최적의 방법을 선택하는 것이 그리디 알고리즘입니다. 
 
 그렇다면 그리디 알고리즘은 어떨때 사용하면 좋을까요?
 
 그리디 알고리즘이 가장 기본적이고 쉬운 개념의 알고리즘이다 보니, 우선 해당 문제를 가장 일차원적으로 생각하며 그리디 알고리즘을 사용한 해결법을 찾은 후에 해당 방법이 정당성을 가지는 지 확인 후 현재 선택하는 방법에 대한 최적의 방법일 뿐이 아니라 전체적인 문제를 해결하는데에 문제가 없는 방법이라는 정당성이 확인 되면 그리디 알고리즘을 사용 할 수 있습니다.
 
 
 # 2. 예제 문제 풀어 보기 (프로그래머스)
 
 ###  체육복 (그리디 알고리즘 레벨 1.)
 
 #### 문제 설명
 
 ```
 점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이
 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어,
 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다.
 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 
 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려,
 최대한 많은 학생이 체육수업을 들어야 합니다.
 
전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 
여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때
체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.
 ```

**제한사항**
- 전체 학생의 수는 2명 이상 30명 이하입니다.
- 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
- 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
- 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.
- 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 - 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.


**입출력 예**
  
 | n | lost | reserve  | return |
| -- | - | -- |  --  |
| 5 |  [2, 4]   | [1, 3, 5] | 5 |
| 5 | [2, 4] | [3] | 4 |
| 3 | [3] | [1] | 2 |
 
 
**입출력 예 설명**

예제 #1
1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.

예제 #2
3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.




답안 코드

```javascript

function solution(n, lost, reserve) {
    let answer = n; // 학생 수를 기본 값으로 할당
    const newLostArray = []; // lost와 reserve 배열에 공통적으로 들어가 있는 학생 번호는 lost에서 제외 시켜 줘야 함으로 새로운 배열  선언
    let count = 0; // 빌려 받은 학생의 수
    
    
    // 먼저 lost배열과 reserve 배열에 공통적으로 들어가 있는 학생은 누구에게도
    // 빌려 주지 못하고 자기 자신에게만 빌려 줄 수 있으므로 두 배열에서 제외 시켜야 한다.
    for (const value of lost) {
    // lost 학생 번호 중 reseve에  같은 번호가 있는지 확인
        if(reserve.includes(value)) {
            const lostIndex = reserve.indexOf(value);
            // 있다면 해당 학생은 빌려 줄 수 있는 학생 배열에서 삭제
            reserve.splice(lostIndex, 1);
        } else {
            //  lost, reseve 두배열에 공통적으로 들어 있지 않은  lost학생만 새로운 배열에 추가
            newLostArray.push(value);
        }
    }
    
    // 지금 부터는  잃어 버린 학생들의 앞, 뒷 번호가 reserve배열에 있는지 확인하면 된다.
    for (const value of newLostArray) {
    
        // 잃어 버린 학생의 앞 번호가 빌려 줄 수 있는 학생 배열에 있는지 확인
        if (reserve.includes(value - 1)) {
            const lostIndex = reserve.indexOf(value - 1);
            // 있다면 빌려 준 후 빌려준 학생의 번호는 reserve배열에서 삭제
            reserve.splice(lostIndex, 1);
            // 빌림 받은 학생의 수 증가
            count++;
        // 뒷 번호 비교 밑 확인
        } else if (reserve.includes(value + 1)) {
            const lostIndex = reserve.indexOf(value + 1);
            reserve.splice(lostIndex, 1);
            count++;
        }
    }

    
    // answer은 기본 값이 학생 전체 수 이기에 잃어 버린 학생의 수만큼 빼줘야 한다. 
    // 또한 위 작업에서 빌림 받은 학생의 수를 파악 할 수 있으므로 잃어 버린 학생의 수에서
    // 빌림 받은 학생의 수 만큼 빼주면 답이 나온다.
    return answer -= newLostArray.length - count;
}

```


 
 
 
